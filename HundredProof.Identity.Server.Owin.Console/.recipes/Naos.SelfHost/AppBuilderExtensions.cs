// --------------------------------------------------------------------------------------------------------------------
// <copyright file="AppBuilderExtensions.cs" company="Naos">
//   Copyright (c) Naos 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in Naos.Recipes.Api.SelfHost.Bootstrapper.Common source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace HundredProof.Identity.Server.Owin.Console
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.IO.Compression;
    using System.Linq;
    using System.Threading.Tasks;
    using System.Web.Cors;

    using static System.FormattableString;

    using Microsoft.AspNetCore.Builder;
    using Microsoft.AspNetCore.Cors.Infrastructure;

    /// <summary>
    /// Internal extensions to the <see cref="IApplicationBuilder" />.
    /// </summary>
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("Naos.Recipes.Api.SelfHost.Bootstrapper.Common", "See package version number")]
    internal static class AppBuilderExtensions
    {
        /// <summary>
        /// Setup CORS on the <see cref="IApplicationBuilder" />.
        /// </summary>
        /// <param name="app"><see cref="IApplicationBuilder" /> to setup.</param>
        /// <param name="hostingSettings">Hosting settings.</param>
        /// <returns>The modified application.</returns>
        public static IApplicationBuilder UseCors(this IApplicationBuilder app, HostingSettings hostingSettings)
        {
            var cors = hostingSettings.Cors;

            if (cors == null || !cors.Origins.Any())
            {
                throw new InvalidOperationException(Invariant($"Provided {nameof(HostingSettings)} did not have {nameof(HostingSettings.Cors)} configured."));
            }

            var allowAnyOrigin = cors.Origins.FirstOrDefault(o => o == "*") != null;

            var corsPolicy = new Microsoft.AspNetCore.Cors.Infrastructure.CorsPolicy
            {
                IsOriginAllowed = s => allowAnyOrigin,
                SupportsCredentials = cors.SupportsCredentials,
                PreflightMaxAge = cors.PreflightMaxAge,
            };

            cors.Origins.ToList().ForEach(corsPolicy.Origins.Add);
            cors.Headers.ToList().ForEach(corsPolicy.Headers.Add);
            cors.Methods.ToList().ForEach(corsPolicy.Methods.Add);
            cors.ExposedHeaders.ToList().ForEach(corsPolicy.ExposedHeaders.Add);

            void PolicyBuilderLogic(CorsPolicyBuilder policyBuilder)
            {

            }

            return app.UseCors(PolicyBuilderLogic);
        }

        private static IReadOnlyDictionary<string, Func<Stream, Stream>> createCompressionStream =
            new Dictionary<string, Func<Stream, Stream>>(StringComparer.OrdinalIgnoreCase)
            {
                {
                    "gzip",
                    destinationStream => new GZipStream(destinationStream, CompressionMode.Compress, leaveOpen: true)
                },
                {
                    "deflate",
                    destinationStream => new DeflateStream(destinationStream, CompressionMode.Compress, leaveOpen: true)
                },
            };

        ///// <summary>
        ///// Uses the g-zip deflate compression.
        ///// </summary>
        ///// <param name="app">The application.</param>
        ///// <param name="compressResponsesOver">The size over which responses should be compressed.</param>
        ///// <param name="bufferSize">Size of the buffer.</param>
        ///// <returns>
        ///// The modified application.
        ///// </returns>
        //public static IApplicationBuilder UseGzipDeflateCompression(this IApplicationBuilder app, int compressResponsesOver = 4096, int bufferSize = 8196)
        //{
        //    if (app == null)
        //    {
        //        throw new ArgumentNullException(nameof(app));
        //    }

        //    app.Use(async (context, next) =>
        //    {
        //        var acceptEncoding = (context.Request.Headers["Accept-Encoding"] ?? string.Empty).ToLowerInvariant();
        //        var acceptedEncodings = acceptEncoding.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries).Select(s => s.Trim());
        //        var acceptedEncoding = acceptedEncodings.FirstOrDefault(e => createCompressionStream.ContainsKey(e));

        //        if (acceptedEncoding == null)
        //        {
        //            await next.Invoke();
        //        }
        //        else
        //        {
        //            // Copy original value and restore in finally
        //            var body = context.Response.Body;
        //            try
        //            {
        //                // Underlying source will be written to source
        //                using (var responseStream = new MemoryStream())
        //                {
        //                    context.Response.Body = responseStream;
        //                    await next.Invoke();

        //                    if (responseStream.Length <= compressResponsesOver)
        //                    {
        //                        await responseStream.CopyTo(body, context, bufferSize);
        //                    }
        //                    else
        //                    {
        //                        await responseStream.CompressTo(body, context, createCompressionStream, acceptedEncoding, bufferSize);
        //                    }
        //                }
        //            }
        //            finally
        //            {
        //                context.Response.Body = body;
        //            }
        //        }
        //    });

        //    return app;
        //}

        //private static async Task CompressTo(this Stream source, Stream destination, IOwinContext context, IReadOnlyDictionary<string, Func<Stream, Stream>> createCompressionStream, string acceptedEncoding, int bufferSize)
        //{
        //    using (var compressedResponse = new MemoryStream())
        //    {
        //        // Need to open and close compression stream for it to write all info to output stream
        //        // See: https://blogs.msdn.microsoft.com/bclteam/2006/05/10/using-a-memorystream-with-gzipstream-lakshan-fernando/
        //        using (var compressionStream = createCompressionStream[acceptedEncoding](compressedResponse))
        //        {
        //            source.Seek(0, SeekOrigin.Begin);
        //            await source.CopyToAsync(compressionStream, bufferSize, context.Request.CallCancelled);
        //        }

        //        context.Response.Headers.Set("Content-Encoding", acceptedEncoding);
        //        await compressedResponse.CopyTo(destination, context, bufferSize);
        //    }
        //}

        //private static async Task CopyTo(this Stream source, Stream destination, IOwinContext context, int bufferSize)
        //{
        //    source.Seek(0, SeekOrigin.Begin);
        //    context.Response.ContentLength = source.Length;
        //    await source.CopyToAsync(destination, bufferSize, context.Request.CallCancelled);
        //}
    }
}